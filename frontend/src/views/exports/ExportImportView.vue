<template>
  <div class="export-detail-page">
    <div class="breadcrumb-nav">
      <router-link to="/exports" class="breadcrumb-link">
        <font-awesome-icon icon="arrow-left" /> Back to Exports
      </router-link>
    </div>
    <div class="header">
      <h1>Upload and Register Export File</h1>
    </div>

    <!-- Error Display -->
    <div v-if="error" class="error-message">
      <font-awesome-icon icon="exclamation-triangle" />
      {{ error }}
    </div>

    <!-- Upload Form -->
    <form @submit.prevent="handleSubmit">
      <div class="export-card">
        <div class="card-header">
          <h2>Upload XML Export File</h2>
        </div>
        <div class="card-body">
          <p class="form-description">
            This must be an XML export file created by Inventario. Once uploaded, it will be available in your list of exports for restoration.
          </p>
          <!-- File Upload -->
          <div class="form-group">
            <label for="file-upload">XML Export File</label>
            <FileUploader
              :multiple="false"
              accept=".xml,application/xml,text/xml"
              upload-prompt="Drag and drop XML export file here"
              @upload="handleFileUpload"
            />
            <div class="form-help">
              Select an XML export file that was previously generated by Inventario
            </div>
            <div v-if="formError?.source_file_path" class="field-error">
              {{ formError.source_file_path }}
            </div>
          </div>

          <!-- Description -->
          <div class="form-group">
            <label for="description">Description</label>
            <input
              id="description"
              v-model="form.description"
              type="text"
              class="form-control"
              placeholder="Enter a description for this imported export"
              maxlength="500"
              required
            />
            <div class="form-help">
              Provide a description to identify this imported export
            </div>
            <div v-if="formError?.description" class="field-error">
              {{ formError.description }}
            </div>
          </div>

          <!-- Form Actions -->
          <div class="form-actions">
            <router-link to="/exports" class="btn btn-secondary">
              Cancel
            </router-link>
            <button
              type="submit"
              class="btn btn-success"
              :disabled="!canSubmit || creating"
            >
              <font-awesome-icon :icon="creating ? 'spinner' : 'upload'" :spin="creating" />
              {{ creating ? 'Importing...' : 'Import Export' }}
            </button>
          </div>
        </div>
      </div>
    </form>

    <!-- Form Errors -->
    <div v-if="formError && Object.keys(formError).length > 0" class="form-error">
      <h3>Please correct the following errors:</h3>
      <ul>
        <li v-for="(message, field) in formError" :key="field">
          <strong>{{ field }}:</strong> {{ message }}
        </li>
      </ul>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useRouter } from 'vue-router'
import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome'
import { useToast } from 'primevue/usetoast'
import FileUploader from '@/components/FileUploader.vue'
import exportService from '@/services/exportService'


const router = useRouter()
const toast = useToast()

const error = ref('')
const creating = ref(false)
const formError = ref<Record<string, string> | null>(null)
const uploadedFilePath = ref('')

const form = ref({
  description: '',
  source_file_path: ''
})

const canSubmit = computed(() => {
  return form.value.description.trim() &&
         uploadedFilePath.value &&
         !creating.value
})

const handleFileUpload = async (files: File[]) => {
  if (files.length === 0) return

  const file = files[0]

  // Validate file type
  if (!file.name.toLowerCase().endsWith('.xml')) {
    error.value = 'Please select a valid XML file'
    return
  }

  try {
    error.value = ''

    // Upload the file using the uploads/restores endpoint
    const formData = new FormData()
    formData.append('files', file)

    const response = await fetch('/api/v1/uploads/restores', {
      method: 'POST',
      body: formData,
    })

    if (!response.ok) {
      const errorData = await response.json()
      throw new Error(errorData.errors?.[0]?.detail || `Failed to upload file: ${response.statusText}`)
    }

    const result = await response.json()
    uploadedFilePath.value = result.attributes.fileNames[0]
    form.value.source_file_path = result.attributes.fileNames[0]

    // Set default description if not provided
    if (!form.value.description) {
      const fileName = file.name.replace(/\.[^/.]+$/, '') // Remove extension
      form.value.description = `Imported from ${fileName}`
    }

    toast.add({
      severity: 'success',
      summary: 'File Uploaded',
      detail: `File "${file.name}" uploaded successfully`,
      life: 3000
    })
  } catch (err: any) {
    console.error('Error uploading file:', err)
    error.value = err.message || 'Failed to upload file'
  }
}

const scrollToFirstError = () => {
  setTimeout(() => {
    const firstError = document.querySelector('.field-error, .form-error')
    if (firstError) {
      firstError.scrollIntoView({ behavior: 'smooth', block: 'center' })
    }
  }, 100)
}

const pollImportStatus = (exportId: string) => {
  let attempts = 0
  const maxAttempts = 300 // 10 minutes with 2s intervals
  const intervalMs = 2000

  const poll = async () => {
    try {
      attempts++
      const response = await exportService.getExport(exportId)
      const exportData = response.data.data.attributes

      // Check if import is complete
      if (exportData.status === 'completed') {
        toast.add({
          severity: 'success',
          summary: 'Import Completed',
          detail: `Import operation "${form.value.description}" completed successfully`,
          life: 8000
        })
        return
      } else if (exportData.status === 'failed') {
        toast.add({
          severity: 'error',
          summary: 'Import Failed',
          detail: exportData.error_message || 'Import operation failed',
          life: 10000
        })
        return
      }

      // Check if we've exceeded max attempts
      if (attempts >= maxAttempts) {
        toast.add({
          severity: 'warn',
          summary: 'Import Monitoring Timeout',
          detail: 'Lost connection to import status updates. Check the export details page for current status.',
          life: 8000
        })
        return
      }

      // Schedule next poll if still in progress
      if (exportData.status === 'pending' || exportData.status === 'in_progress') {
        setTimeout(poll, intervalMs)
      }
    } catch (error) {
      console.error('Error polling import status:', error)
      toast.add({
        severity: 'warn',
        summary: 'Import Monitoring Lost',
        detail: 'Lost connection to import status updates. Check the export details page for current status.',
        life: 8000
      })
    }
  }

  // Start polling
  setTimeout(poll, intervalMs)
}

const handleSubmit = async () => {
  if (!canSubmit.value) return

  try {
    creating.value = true
    error.value = ''
    formError.value = null

    const requestData = {
      data: {
        type: 'exports',
        attributes: {
          description: form.value.description.trim(),
          source_file_path: form.value.source_file_path
        }
      }
    }

    const response = await exportService.importExport(requestData)
    const exportId = response.data.data.id

    toast.add({
      severity: 'success',
      summary: 'Import Started',
      detail: `Import operation "${form.value.description}" has been started and is running in the background`,
      life: 5000
    })

    // Start polling for import status updates
    pollImportStatus(exportId)

    // Navigate to the imported export detail view immediately
    router.push(`/exports/${exportId}`)
  } catch (err: any) {
    console.error('Error importing export:', err)

    if (err.response?.data?.errors) {
      // Handle validation errors from API
      const apiErrors = err.response.data.errors
      const errorObj: Record<string, string> = {}

      apiErrors.forEach((error: any) => {
        if (error.source?.pointer) {
          const field = error.source.pointer.replace('/data/attributes/', '')
          errorObj[field] = error.detail
        }
      })

      if (Object.keys(errorObj).length > 0) {
        formError.value = errorObj
        scrollToFirstError()
        return
      }
    }

    error.value = err.response?.data?.errors?.[0]?.detail || 'Failed to import export'
  } finally {
    creating.value = false
  }
}
</script>

<style lang="scss" scoped>
@use '@/assets/export-detail-styles';
@use '@/assets/main' as *;

.header {
  margin-bottom: 2rem;

  h1 {
    margin: 0;
    color: $text-color;
    font-size: 2rem;
  }
}

.form-description {
  margin: 0 0 1.5rem;
  color: $text-secondary-color;
  font-size: 1rem;
  line-height: 1.5;
  padding: 1rem;
  background-color: rgba($primary-color, 0.05);
  border-left: 4px solid $primary-color;
  border-radius: $default-radius;
}

.form-help {
  font-size: 0.875rem;
  color: $text-secondary-color;
  margin-top: 0.25rem;
  line-height: 1.4;
}

.field-error {
  color: $error-color;
  font-size: 0.875rem;
  margin-top: 0.25rem;
}
</style>
