package services_test

import (
	"context"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	qt "github.com/frankban/quicktest"

	"github.com/denisvmedia/inventario/models"
	"github.com/denisvmedia/inventario/registry/memory"
	"github.com/denisvmedia/inventario/services"
)

// errorAuditLogRegistry wraps an in-memory registry and always returns an error from Create.
// Used to verify that LogAuth is truly best-effort and does not propagate write errors.
type errorAuditLogRegistry struct {
	*memory.AuditLogRegistry
}

func (r *errorAuditLogRegistry) Create(_ context.Context, _ models.AuditLog) (*models.AuditLog, error) {
	return nil, errors.New("simulated registry write failure")
}

func TestAuditService_LogAuth_NilReceiver(t *testing.T) {
	// A nil *AuditService must not panic â€” the nil check in LogAuth guards against this.
	var svc *services.AuditService
	svc.LogAuth(context.Background(), "login", nil, nil, true, nil, nil)
}

func TestAuditService_LogAuth_NilRegistry(t *testing.T) {
	// NewAuditService with a nil registry must behave as a no-op.
	svc := services.NewAuditService(nil)
	svc.LogAuth(context.Background(), "login", nil, nil, true, nil, nil)
}

func TestAuditService_LogAuth_BestEffort(t *testing.T) {
	// When the registry fails on Create, LogAuth must not return an error or panic.
	// The error is logged internally (via slog) but never propagated to callers.
	reg := &errorAuditLogRegistry{AuditLogRegistry: memory.NewAuditLogRegistry()}
	svc := services.NewAuditService(reg)
	// This call must complete without panicking even though Create will fail.
	svc.LogAuth(context.Background(), "login", nil, nil, true, nil, nil)
}

func TestAuditService_LogAuth_FieldPopulation(t *testing.T) {
	c := qt.New(t)
	ctx := context.Background()

	reg := memory.NewAuditLogRegistry()
	svc := services.NewAuditService(reg)

	userID := "user-abc"
	tenantID := "tenant-xyz"
	errMsg := "invalid credentials"

	req := httptest.NewRequest("GET", "/", nil)
	req.Header.Set("User-Agent", "Mozilla/5.0")
	req.Header.Set("X-Real-IP", "9.8.7.6")

	svc.LogAuth(ctx, "login", &userID, &tenantID, false, req, &errMsg)

	entries, err := reg.List(ctx)
	c.Assert(err, qt.IsNil)
	c.Assert(entries, qt.HasLen, 1)

	entry := entries[0]
	c.Assert(entry.ID, qt.Not(qt.Equals), "") // UUID generated by the service
	c.Assert(entry.Action, qt.Equals, "login")
	c.Assert(entry.UserID, qt.IsNotNil)
	c.Assert(*entry.UserID, qt.Equals, userID)
	c.Assert(entry.TenantID, qt.IsNotNil)
	c.Assert(*entry.TenantID, qt.Equals, tenantID)
	c.Assert(entry.Success, qt.IsFalse)
	c.Assert(entry.ErrorMessage, qt.IsNotNil)
	c.Assert(*entry.ErrorMessage, qt.Equals, errMsg)
	c.Assert(entry.IPAddress, qt.Equals, "9.8.7.6")
	c.Assert(entry.UserAgent, qt.Equals, "Mozilla/5.0")
	c.Assert(entry.Timestamp.IsZero(), qt.IsFalse) // Timestamp set by the registry
}

func TestAuditService_LogAuth_NilRequest(t *testing.T) {
	// When r is nil, no IP address or User-Agent should be stored in the entry.
	c := qt.New(t)
	ctx := context.Background()

	reg := memory.NewAuditLogRegistry()
	svc := services.NewAuditService(reg)

	svc.LogAuth(ctx, "logout", nil, nil, true, nil, nil)

	entries, err := reg.List(ctx)
	c.Assert(err, qt.IsNil)
	c.Assert(entries, qt.HasLen, 1)
	c.Assert(entries[0].IPAddress, qt.Equals, "")
	c.Assert(entries[0].UserAgent, qt.Equals, "")
}

func TestAuditService_LogAuth_IPExtraction(t *testing.T) {
	// Table-driven tests for clientIPFromRequest, exercised indirectly through LogAuth.
	tests := []struct {
		name   string
		setup  func(req *http.Request)
		wantIP string
	}{
		{
			name: "X-Forwarded-For single IP",
			setup: func(req *http.Request) {
				req.Header.Set("X-Forwarded-For", "1.2.3.4")
			},
			wantIP: "1.2.3.4",
		},
		{
			name: "X-Forwarded-For multiple IPs takes first and trims whitespace",
			setup: func(req *http.Request) {
				req.Header.Set("X-Forwarded-For", " 10.0.0.1 , 172.16.0.1, 192.168.1.1")
			},
			wantIP: "10.0.0.1",
		},
		{
			name: "X-Real-IP used when no X-Forwarded-For",
			setup: func(req *http.Request) {
				req.Header.Set("X-Real-IP", "5.6.7.8")
			},
			wantIP: "5.6.7.8",
		},
		{
			name: "X-Forwarded-For takes precedence over X-Real-IP",
			setup: func(req *http.Request) {
				req.Header.Set("X-Forwarded-For", "11.22.33.44")
				req.Header.Set("X-Real-IP", "99.99.99.99")
			},
			wantIP: "11.22.33.44",
		},
		{
			name: "RemoteAddr with port strips port",
			setup: func(req *http.Request) {
				req.RemoteAddr = "192.168.1.100:54321"
			},
			wantIP: "192.168.1.100",
		},
		{
			name: "RemoteAddr IPv6 with port strips brackets and port",
			setup: func(req *http.Request) {
				req.RemoteAddr = "[::1]:12345"
			},
			wantIP: "::1",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := qt.New(t)
			ctx := context.Background()

			reg := memory.NewAuditLogRegistry()
			svc := services.NewAuditService(reg)

			req := httptest.NewRequest("GET", "/", nil)
			tt.setup(req)

			svc.LogAuth(ctx, "login", nil, nil, true, req, nil)

			entries, err := reg.List(ctx)
			c.Assert(err, qt.IsNil)
			c.Assert(entries, qt.HasLen, 1)
			c.Assert(entries[0].IPAddress, qt.Equals, tt.wantIP)
		})
	}
}
